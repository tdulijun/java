回顾:
线程 --> 进程和线程
并行 (某个一时刻点上发生)和并发(某一个时间段发生)
线程的两种实现方式
继承Thread
实现Runnable
无论是这两种的哪一种都需要实现run方法
线程逻辑写到run方法
线程常用方法:
获取当前线程状态,线程休眠 ,线程合并 ,线程中断
线程千万不要调用stop未知异常,停止线程 --->中断

中断标记 不能停止线程,添加标记, 告诉线程有个停止信息
检查中断标记 ,检查到了  停止线程(return)  没有检查到继续执行

多线程并发访问临介资源
需求:卖票,火车 4个窗口  票一共100张,四个窗口买
   不能出现400张 ,不能出现重票 1窗口97票 2窗口97票  不能出现负数  
  变量唯一: ---> static 全局静态变量所有对象是共享
看 ThreadSellTicket

线程锁-->(同步代码块)
多线程并发访问临介资源时为了保证资源的安全(防止冲突)-->线程锁

对象锁 --> 作为锁 参数是不一样 ---> 对象
Synchronized关键字-->线程添加一个锁对象,对象锁中的对象必须是唯一的不然是锁住的
ps:个人建议不要使用this作为锁对象--> ""空字符串 --> String底层实现原理
   ""--> String对象 --> 字符串池中先寻找,若没有创建"",有直接返回已经创建好的字符串地址
    --> ""地址是不会重复的而且是唯一的
    String str1 = "abc";
    String str2 = "abc";
    String str3 = new String("abc");
    //是不是地址 ,千万别不要这样比较
    System.out.println(str1 == str2);true
    System.out.println(str1 == str3); false
    System.out.println(str1.equlas(str2));
    
 语法:
    synchronized(对象){ //同步代码块-->锁  对象就会被作为锁,所有线程共享一个
                                                  作为参数的对象,千万不能重复,不然绝对是锁不住的
             同步代码--> 线程需要操作的逻辑(控制什么)
                                    
    
    }   
    
  同步方法--> 对象锁方法 --> 当前锁对象是this 不能更改
                      创建的对象是唯一的,这个同步方法无法锁住资源
  语法:
  访问权限修饰符 synchronized  返回值类型 方法名(){
                 操作的代码
  } 
  看synchronized包

类锁 -->  作为锁 参数是不一样 --> 类

语法:
    synchronized(类){ //类必须是唯一的 --> 类名.class --> 可以获取当前类的字节码文件
                        		就可以保证是唯一的 String.class
    
             同步代码--> 线程需要操作的逻辑(控制什么)
                                    
    
    }   
    
  同步方法--> 类锁方法 -->  锁的是.class文件 --> 类的字节码文件
  语法:
  访问权限修饰符 synchronized static  返回值类型 方法名(){
                 操作的代码
  } 
总结:
  在开发中若需要使用同步代码块(锁),建议大家使用对象锁的形式
  在开发中若需要使用同步方法,建议大家使用类锁方法 synchronized static 修饰符的方法 
  
Synchronized的好处和坏处
好处:保证在多线程并发访问同步操作的情况下,保证线程是安全的
坏处:若使用synchronized方法/代码块性能会降低
所以尽量减少synchronized的作用域
    看Staticsynchronized包
    
Java5以后的新特性
   为了简洁代码提供了一个可以替代synchronized同步代码块的类
   Lock 锁 类   ---> 同步代码块(对象锁)
   Lock 进行同步 相当于 使用 synchronized(对象){}
     涉及到一些Lock中方法  所 对应 synchronized代码块
    void  lock(); 锁     ---> synchronized(对象)
    void  unlock() 开锁 --->  线程完毕会释放锁对象synchronized代码块是看不到   
ps:Lock必须记住替代的是对象锁,所以Lock使用的就是对象,对象必须是唯一的
       通过这个锁,修改线程通信

看Lock包

生产者消费者模式(线程通信)
线程通信:在不同的线程执行不同的任务如果这些任务有某些关系,线程只能通过传递信息来达到彼此知晓的目的
                线程之间可以彼此协调工作
需要要两个模型
生产者producer   / 消费者consumer 通信操作

为什么生产者不直接将数据传递给消费者,而是将数据保存到一个共享类.然后,消费者在从共享类中将数去取走
为了满足面向对象的设计要求:低耦合
    使用一个中间对象,屏蔽了生产者和消费者直接的数据交互
    
需要产生的数据:
姓名- 性别    --> 春哥 --> 男     
                              凤姐 --> 女   

看ProducerAndConsumer包
    
问题:
1.在没有使用Sleep方法之前,所看到的结果是统一的

2.在产生数据的时候,在打印的时候同时添加Sleep方法
凤姐-男
凤姐-男
春哥-女
 当前生产者生产出春哥-男,此时消费没有消费,生产者会继续生产,产出姓名为凤姐,此时消费者消费了
所以就会出现一个问题 凤姐-男


解决方案:
1.只要保证一个生产顺序,让姓名和性别保持同步,中间不会被消费者线程进来消费可以使用同步代码块
2.生产者生产完数据之后,并没有停止生产,而且也没有告知消费者过来消费
  消费者消费完数据之后,并没有继续停止消费,而且也没有告知生产者继续生产
  若达成上面描述的状态:
  打印的内容是交替执行并且不会出现错误信息
   春哥-男   --> 春哥 - 男 
   凤姐-女   --> 凤姐-女 

线程通信-wait和notify方法介绍:
java.lang.Object类提供类两类用于操作线程通信的方法.
wait():执行该方法的线程对象释放同步锁,JVM把该线程存放到等待池中,等待其他的线程唤醒该线程.
notify:执行该方法的线程唤醒在等待池中等待的任意一个线程,把线程转到锁池中等待.
notifyAll():执行该方法的线程唤醒在等待池中等待的所有的线程,把线程转到锁池中等待.
注意:上述方法只能被同步监听锁对象来调用,否则报错IllegalMonitorStateException..
------------------------------------------
假设A线程和B线程共同操作一个X对象(同步锁),A,B线程可以通过X对象的wait和notify方法来进行通信,
流程如下:
1:当A线程执行X对象的同步方法时,A线程持有X对象的锁,B线程没有执行机会,B线程在X对象的锁池中等待.
2:A线程在同步方法中执行X.wait()方法时,A线程释放X对象的锁,进入A线程进入x对象的等待池中.
3:在X对象的锁池中等待锁的B线程获取X对象的锁,执行X的另一个同步方法.
4:B线程在同步方法中执行X.notify()方法时,JVM把A线程从X对象的等待池中移动到X对象的锁池中,等待获取锁.
5:B线程执行完同步方法,释放锁.A线程获得锁,继续执行同步方法.
    
  看ProducerAndConsumer2包  
  
 生产者消费者模式文字描述执行过程
 1.首先要进行线程通信就需要使用wait和notfiy方法,这两个方法必须使用在同步代码块中不然就出现异常IllegalMonitorStateException
 2.调用wait和notfiy这两个方法必须是同步代码块中对象锁中的对象,不然是无法完成等待和唤醒操作的
 3.以上步骤都完成进入分析
    生产者逻辑:
 	3.1为了保证生产者和消费者之间能得到一个彼此状态的信息所以会定义一个彼此共享的变量
 	    static boolean isEmpty = true;
 	    boolean类型的默认初始值是false,为了方便操作此时将数据之设置为true
               这里是 ture 代表的是没有数据    false 代表的数据已经被生产了
    3.2在生产者逻辑中提供如何信息首先生产者和消费者之间必须是相同的锁对象,所以synchronized中都使用的是"" 字符串
              好处是他们都会进入同一个锁池中,可以方便使用  
    3.3然后判断当前数据的状态,只所以这里使用 !isEmpty值 是因为:
          isEmpty初始值是true代表没数据,生产者不能等待而是要生产,所以这里要是使用取非处理
    3.4然后不等待那么就要进入数据的产生过程,产生过程执行完毕之后
    3.5就需要修改生产者和消费者之间的共享数据isEmpty来位置彼此之间的状态
       	产生数据后isEmpty的值会被修改为false 证明已经产生了数据
    3.6最后一步,数据生产完成之后,我们需通知消费者来进行消费,所以此时消费可能有两种状态
          第一种:线程的第一次执行是生产者而非消费者,那么消费是清醒状态并未等待,所以会出现空唤醒
          第二种:消费者已经先执行过了,而生产者是后执行,所以此时就可以对消费进行唤醒操作      
            
   消费者逻辑:
    4.1为了保证生产者和消费者之间能得到一个彼此状态的信息所以会定义一个彼此共享的变量
 	    static boolean isEmpty = true 这个值是初始值 只要生产者生产完成数据了这个值必然会被修改为false
 	4.2所以在消费者消费数据的时候先进行 isEmpty的判断操作
 	      这个操作主要就是为了保证有数据,所以只要值是true那么证明没有数据而消费者也会进入等待状态
 	4.3消费者若是没有进入等待状态,只能说明当前已经生产好了数据那么此时的isEmpty的值一定是false
 	4.4消费者消费数据,消费完数据之后,必须要进行状态更改将isEmpty重新修改为true,这样生产者才会继续生产
 	4.5消费者消费数据,证明生产者已经生产,必然生产者在生产数据之后要进入等待状态,所以消费也需要进行notfiy操作进行生产者唤醒          

Lock锁的形式来完成生产者消费模式 
Lock锁替代了Synchronized对象锁
创建锁对象 Lock lock = new ReentrantLock();
lock.lock() 和  lock.unlock();   替代--->  synchronized(""){}
Condition替代Object中所提供的线程等待和唤醒操作,配合Lock锁进行使用
await() 线程等待        signal() 唤醒单个线程   signalAll() 唤醒多个线程

ps:要判断共享资源状态
   if(!isEmpty)  if(isEmpty)
建议大家将当前if 改为 while --> 比if多进行一次比较判断  

死锁(了解)
多线程通信的时候造成死锁状态,死锁无法解决,只能避免
例子:
当A线程等待由B线程所持有的锁对象,而B线程等待由A线程所持有的锁对象,此时死锁就发生了
JVM是不会避免这种个问题发生的,所以程序猿在写线程的时候尽量避免死锁发生

死锁 不等于 等待

案例:
张三对李四说,你给我画,我就把书给你....
李四对张三说,你给我书,我就把画给你....
看DieLock包

单利在线程模式下的安全问题
两种设计模式
懒汉模式
1.私有化构造方法
2.定一个静态私有属性数据类型是当前类类型
3.提供一个静态方法返回值类型是当前类类型,获取当前类的对象
    判断一下当前属性是否为null 若为null 创建当前对象
    返回当前对象
    判断一下当前属性是否为null 若不为null 不创建直接返回
 
饿汉模式
1.私有化构造方法
2.定一个静态私有属性数据类型是当前类类型并对当前属性进行初始化
3.提供一个静态方法返回值类型是当前类类型,获取当前类的对象
   直接返回属性即可
   
简单单利
1.私有化构造方法
2.提供一个公有静态不可变的当前类类型的属性并初始化


枚举单利
定义常量名

在多线程并发访问的前提下懒汉单利是不安全的
双重检查加锁:
　　可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？
　　所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

　　“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。

注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。
提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。
推荐使用:饿汉式写法,简单,安全,粗暴   
看Single包


生命周期图
看线程声明周期图.png
完整解释
1:新建状态(new):使用new创建一个线程对象,仅仅在堆中分配内存空间,在调用start方法之前.
   新建状态下,线程压根就没有启动,仅仅只是存在一个线程对象而已.
   Thread t = new Thread();//此时t就属于新建状态
    当新建状态下的线程对象调用了start方法,此时从新建状态进入可运行状态.
线程对象的start方法只能调用一次,否则报错:IllegalThreadStateException.

2:可运行状态(runnable):分成两种状态，ready和running。分别表示就绪状态和运行状态。
	就绪状态:线程对象调用start方法之后,等待JVM的调度(此时该线程并没有运行).
	运行状态:线程对象获得JVM调度,如果存在多个CPU,那么允许多个线程并行运行.

3:阻塞状态(blocked):正在运行的线程因为某些原因放弃CPU,暂时停止运行,就会进入阻塞状态.
 此时JVM不会给线程分配CPU,直到线程重新进入就绪状态,才有机会转到运行状态.
 阻塞状态只能先进入就绪状态,不能直接进入运行状态.
 阻塞状态的两种情况:
1):当A线程处于运行过程时,试图获取同步锁时,却被B线程获取.此时JVM把当前A线程存到对象的锁池中,A线程进入阻塞状态.
2):当线程处于运行过程时,发出了IO请求时,此时进入阻塞状态.
		
4:等待状态(waiting)(等待状态只能被其他线程唤醒):此时使用的无参数的wait方法,
1):当线程处于运行过程时,调用了wait()方法,此时JVM把当前线程存在对象等待池中.

5:计时等待状态(timed waiting)(使用了带参数的wait方法或者sleep方法) 
1):当线程处于运行过程时,调用了wait(long time)方法,此时JVM把当前线程存在对象等待池中.
2):当前线程执行了sleep(long time)方法.
6:终止状态(terminated):通常称为死亡状态，表示线程终止.
        1):正常执行完run方法而退出(正常死亡).
        2):遇到异常而退出(出现异常之后,程序就会中断)(意外死亡).
-------------------------------------------------------------------
线程一旦终止,就不能再重启启动,否则报错(IllegalThreadStateException).

在Thread类中过时的方法(因为存在线程安全问题,所以弃用了):
 void suspend() :暂停当前线程
 void resume()  :恢复当前线程
 void stop()  :结束当前线程

























