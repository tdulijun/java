回顾:
数据结构: 计算机存储数据的一种形式
数组,链表,栈,堆 队列, 树,图

数组--> 实现了自己的ArrayList
Java集合
List集合:有序可以存储重复,并且可以使用下标的形式
ArrayList ---> API

ArrayList分析:
大O表示法:表示时间复杂度,专门用来计算性能相关的
增删改查(CRUD)
1.保存:
   若把数据保存在数组的最后一位,最少要操作一次
   若把数组把保存在数组中第一个位置,如果存在多个元素,此时需要操作N次
   平均(N+1)/2 若需要扩容,性能更慢
2.删除操作:
   如果删除 最后一个元素 ,最少操作一次
   如果删除第一个元素,操作N次
  平均(N+1)/2   
3.修改 操作1次 (下标)
3.查询:
  如果使用下标查询元素  操作1次
  如果使用元素查询:此时使用线性搜索  N次
 平均(N+1)/2
 ps:  使用二分查找数组中的元素
  1.排序(从小到大)  
  2.开始的位置和一个结束的位置(数组的最后一位)求和/2 = 中间值
  3.使用要查找的数值 和 中间值进行比较
  4.若当前数值小于中间值 --> 左半区寻找 重现计算中间值 并且 最后的位置需要移动 = 中间值 -1
  5.若当前数值大于中间值 --> 右半区寻找 重新计算中间值 并且 开始值的位置需要移动 = 中间值 +1 
  6.找到就是返回下标(中间值)
  7.交叉 开始值 > 结束值   --> 右半区 --> 开始值+1 > 结束值
                       --> 左半区 --> 开始值 > 结束值 -1 
                       找不到  返回-1 
                       
结论:基于数组结构的ArrayList做查询和修改是非常快,但是做保存和删除比较慢了(数组扩容和减容)

ps:
java7之前 使用new ArrayList创建一个集合对象,一个元素都不存的情况下,对空间需要开始10个空间
java7之后 对创建没有元素的ArrayList做一个优化
     Object[]  arraylist = new  Object[]{}; == ArrayList al = new  ArrayList();
     当第一次使用add方式,才会重新去初始化这个数组


如果就像别保证保存和删除的性能,怎么办?
数据结构:链表
实现双向链表 --> 内部类
成员内部类 静态内部类  局部内部类(打死都不使用 --> 定义在方法体中) 匿名内部类 
public class {
	public void show(){
	 //java7最后 默认添加final --> 只要局部内部类访访问了当前变量
	 //方法体重当前变量需要被局部内部类所使用 --> final
	    int a = 10;  //final
		class A{
		  System.out.println(a);
		}
	}
}
成员内部类和静态内部类的最大区别:
静态内部类使用static修饰 --> 只有内部类才可以使用static修饰 外部类补允许
成员内部类是不能定义static修饰的变量和方法
看Lianbao包


若每次存储数据的话都需要实现双向链表过于繁琐
所以Java集合框架中就提供了一个融合了双向链表和队列的集合



LinkedList集合:
API
看LinkedList包

LinkedList分析
增加:
   双向链表可以直接在第一个或最后一个位置添加节点
   如果是中间添加 ,同样的也是只要1次即可
删除:
  如果是删除第一个元素直接删除即可
   如果是最后一个元素 直接删除即可
   若删除中间的元素:
        若直接找到节点 就是1次
        若是通过下标的方式 (1+N)/2次    
查询:  (N+1)/2 平均
修改     (N+1)/2  平均

总结:LinkedList增加和删除元素效率高,查询和修改元素效率低

ArrayList和LinkedList场景:
查询和修改某个数据结构:推荐使用ArrayList
增加和删除某个数据结构:推荐使用LinkedList
ps:开发中实际使用次数最多的就是 ArrayList --> 数组

Vector和队列和栈 (了解)
ArrayList类是java集合框架出现之后用来取代Vector类的
二者底层实现原理基本都是基于数组(一模一样)  

Vector 所有的方法都使用了线程同步锁synchronized,多线程安全效率低,比较适用于多线程的环境下
ps: 1.5版本一下  swing 图形界面-->当前下的某些方法使用Vector作为参数
ArrayList 所有方法并没有使用线程同步锁,多线程不安全效率高,比较适用于单线程的情况下
Collections.synchronizedList --> 线程安全的集合
Vector的常用方法和ArrayList近乎是一样的

队列是一中线性的类表,特殊之处在于允许在表的前段,进行删除操作,从而可以在表的后端进行插入操作 Queue
先进先出(FIFO)
单向对象(Queue)  双向队列(Deque) --->允许在表的头尾,进行插入和删除工作
栈集合(Stack) --> pop push 它也是一种线性列表(受限制)   后进先出


List集合 
通过图的说明ArrayList和LinkedList可以在List中实现了一些通用的方法
List接口(DRY原则)
接口可以看做是一个特殊的抽象父类
接口同样支持多态 --> 接口可以接受一个实现类的引用
面向接口编程
同理为了达到通用性,在设计方法的时,方法的参数需要是一个集合,使用接口类型作为参数的数据类型
这样一来就可以在方法中使用不同的集合了
例如:
public static void show(List list){


}
当调用哪个show方法时,可以传入的参数有哪些 --> ArrayList 或  LinkedList 或 Vector
可以限制当前方法使用的集合的类型
若以后再使用List接口集合是建议:
List list = new  当前实现类即可(); --->对象的向上转型 ---.>list只能调用父类的方法和属性,子类的特有属性和方法不行了
看List包
剩余方法可以参考API
总结:
Vector类打死都不用,就选着ArrayList
无论是增删改查,可以根据不同的场景选着不同的集合
ps:个人意见就可以完全使用ArrayList就可以了
     不用担心性能,不用担心多线程下的不安全问题 --> collections类
   
集合的遍历方式 4种
普通for循环

增强for循环

迭代器 Iterator
 标准 直接通过集合对象.iterator() -->获取迭代器对象
 boolean hasNext() 判断迭代器中是否还有下一个元素  有返回true 没有返回false 
 E next()  可以获取当前迭代器中存储的元素对象
          
          
          
增强版 listIterator 直接通过集合对象.listIterator   
 法摘要 
 void add(E e) 向迭代器中添加元素 
 
 boolean hasNext() 判断迭代器中是否还有下一个元素
  E next() 获取当前对象
  
 boolean hasPrevious() 判断迭代器中是否还有上一个元素       
 E previous() 获取当前对象。 
 
 void remove() 删除元素 
 void set(E e) 修改元素
          
枚举迭代器(Vector的固有迭代,不用)
并且已经过时,而且被Iteratror所取代


迭代器存在的问题
ConcurrentModificationException并发修改异常
迭代器相当于拷贝了一份原有集合
迭代器和原有集合之前每一个元素存在着一种映射关系
影响到了集合和迭代器堆元素修改时的一些问题

若在迭代其中 使用当前集合对象自身的删除方法,删除集合中的元素,集合中的中元素确实是删减了但是
迭代器中的元素时不变的,所以会出现ConcurrentModificationException

若需要在迭代器中删除元素,需要使用迭代器对象自身的remove,而不是集合中remove
若使用迭代器中的remove修改元素,集合同步会被修改

ps:
当前迭代器迭代器集合的时候会创建一张单索引的表或数据结构只想当前结合.若通过集合的增删功能是修改集合大小
当前迭代器所创建的单索引表或数据结构不会发生改变,在次当执行hasNext方式,迭代器会判断单索引表或数据的大小
是否等于集合的大小,若不等于就抛出异常ConcurrentModificationException并发修改异常

总结:
若使用迭代器遍历数组,绝对不能砸迭代器中使用集合自身的删除增加方法,需要使用迭代器对象本身的增加删除方法


快速失败迭代器问题:
只要在得带器中使用集合对象删除,集合中的倒数第二个元素,这个时候得带器是不会抛出异常的
若删除其他的其他的就会出现异常
假如集合的大小为5,删除了地3个元素(倒数第2个),因为调用了底层的next所以原码中cursor就会进行++
cursor = cursor + 1 3+1 --> 4
hasNext是size原本的值是5,因为删除了一个元素所以大小变成了4, 所以cursor == size 因为条件 cursor != size;
所以为这个时候返回了false,循环是进入不了的就没办法执行next方法,所以就不会报出异常信息
  public boolean hasNext() {
            return cursor != size;
        }

ps:cursor记录当前迭代器修改次数,用来和集合中的size进行比较




Set集合 






             





















 
 
 
 
 
 
 
 
 
 
 
 
 
 